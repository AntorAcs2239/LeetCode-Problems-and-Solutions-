class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n=edges.size();
        vector<int>graph[n+5];
        for(int i=0;i<n;i++)
        {
            int u=edges[i][0];
            int v=edges[i][1];
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
        vector<int>ans;
        int vis[n+5];
        for(int i=n-1;i>=0;i--)
        {
            for(int k=0;k<=n;k++)vis[k]=0;
            int u=edges[i][0];
            int v=edges[i][1];
            int a,b;
            for(int j=0;j<graph[u].size();j++)
            {
                if(graph[u][j]==v)
                {
                    graph[u].erase(graph[u].begin()+j);
                    a=j;
                    break;
                }
            }
            for(int j=0;j<graph[v].size();j++)
            {
                if(graph[v][j]==u)
                {
                    graph[v].erase(graph[v].begin()+j);
                    b=j;
                    break;
                }
            }
            bfs(vis,graph);
            bool flag=true;
            for(int i=1;i<=n;i++)
            {
                if(vis[i]==0)
                {
                    flag=false;
                    break;
                }
            }
            if(flag)
            {
                ans.push_back(edges[i][0]);
                ans.push_back(edges[i][1]);
                break;
            }
            graph[u].insert(graph[u].begin()+a,v);
            graph[v].insert(graph[v].begin()+b,u);
        }
        return ans;
    }
    void bfs(int vis[],vector<int>graph[])
    {
        queue<int>q;
        q.push(1);
        vis[1]=1;
        while(!q.empty())
        {
            int f=q.front();
            q.pop();
            for(auto x:graph[f])
            {
                if(vis[x]==0)
                {
                    vis[x]=1;
                    q.push(x);
                }
            }
        }
    }
};